const mongoose = require('mongoose');
const crypto = require('crypto');

const employeeEntrySchema = new mongoose.Schema({
  // Entry Identification
  entryId: {
    type: String,
    unique: true,
    required: false, // Will be generated by pre-save hook
    trim: true
  },
  
  // Employee Information
  employeeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Employee',
    required: [true, 'Employee ID is required']
  },
  
  // Building Association
  buildingId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: [true, 'Building ID is required']
  },
  
  // Entry Details
  entryTime: {
    type: Date,
    default: Date.now,
    required: true
  },
  
  // Who recorded this entry (Security Guard/Admin)
  recordedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Recorded by is required']
  },
  
  recordedByName: {
    type: String,
    trim: true,
    maxlength: [100, 'Recorded by name cannot exceed 100 characters']
  },
  
  // Entry Purpose/Details
  purpose: {
    type: String,
    trim: true,
    maxlength: [200, 'Purpose cannot exceed 200 characters']
  },
  
  notes: {
    type: String,
    trim: true,
    maxlength: [500, 'Notes cannot exceed 500 characters']
  },
  
  // Status and Tracking
  isActive: {
    type: Boolean,
    default: true
  },
  
  // Timestamps
  createdAt: {
    type: Date,
    default: Date.now
  },
  
  updatedAt: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

// Indexes for better performance
employeeEntrySchema.index({ buildingId: 1, entryTime: -1 });
employeeEntrySchema.index({ employeeId: 1, entryTime: -1 });
employeeEntrySchema.index({ recordedBy: 1 });
employeeEntrySchema.index({ entryId: 1 });

// Pre-save middleware to generate entryId
employeeEntrySchema.pre('save', async function(next) {
  try {
    if (!this.entryId) {
      this.entryId = await this.constructor.generateEntryId();
    }
    this.updatedAt = new Date();
    next();
  } catch (error) {
    next(error);
  }
});

// Virtual for formatted entry time
employeeEntrySchema.virtual('entryTimeFormatted').get(function() {
  return this.entryTime.toLocaleString('en-IN', {
    timeZone: 'Asia/Kolkata',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    hour12: true
  });
});

// Virtual for entry message
employeeEntrySchema.virtual('entryMessage').get(function() {
  const employeeName = this.employeeId?.name || 'Unknown Employee';
  const employeeType = this.employeeId?.employeeTypeDisplay || 'Unknown Type';
  return `${employeeName} (${employeeType}) has entered the building`;
});

// Static method to generate unique entry ID
employeeEntrySchema.statics.generateEntryId = async function() {
  let entryId;
  let isUnique = false;
  
  while (!isUnique) {
    // Generate ID in format: ENTRY_ + timestamp + 4 random chars
    const timestamp = Date.now();
    const randomStr = crypto.randomBytes(2).toString('hex').toUpperCase();
    entryId = `ENTRY_${timestamp}_${randomStr}`;
    
    // Check if ID already exists
    const existingEntry = await this.findOne({ entryId });
    if (!existingEntry) {
      isUnique = true;
    }
  }
  
  return entryId;
};

// Static method to get entries by building
employeeEntrySchema.statics.getByBuilding = function(buildingId, options = {}) {
  const { page = 1, limit = 50, startDate, endDate, employeeType } = options;
  
  const query = { buildingId, isActive: true };
  
  // Date range filter
  if (startDate || endDate) {
    query.entryTime = {};
    if (startDate) query.entryTime.$gte = new Date(startDate);
    if (endDate) query.entryTime.$lte = new Date(endDate);
  }
  
  return this.find(query)
    .populate('employeeId', 'name employeeType employeeTypeDisplay phoneNumber employeeCode')
    .populate('recordedBy', 'name role')
    .populate('buildingId', 'name address')
    .sort({ entryTime: -1 })
    .limit(limit * 1)
    .skip((page - 1) * limit);
};

// Static method to get entries by employee
employeeEntrySchema.statics.getByEmployee = function(employeeId, buildingId) {
  return this.find({ employeeId, buildingId, isActive: true })
    .populate('recordedBy', 'name role')
    .sort({ entryTime: -1 });
};

// Static method to get today's entries
employeeEntrySchema.statics.getTodaysEntries = function(buildingId) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);
  
  return this.find({
    buildingId,
    entryTime: {
      $gte: today,
      $lt: tomorrow
    },
    isActive: true
  })
    .populate('employeeId', 'name employeeType employeeTypeDisplay phoneNumber')
    .populate('recordedBy', 'name role')
    .sort({ entryTime: -1 });
};

// Static method to get entry statistics
employeeEntrySchema.statics.getEntryStats = function(buildingId, startDate, endDate) {
  const matchStage = { buildingId: new mongoose.Types.ObjectId(buildingId), isActive: true };
  
  if (startDate && endDate) {
    matchStage.entryTime = {
      $gte: new Date(startDate),
      $lte: new Date(endDate)
    };
  }
  
  return this.aggregate([
    { $match: matchStage },
    {
      $lookup: {
        from: 'employees',
        localField: 'employeeId',
        foreignField: '_id',
        as: 'employee'
      }
    },
    { $unwind: '$employee' },
    {
      $group: {
        _id: null,
        totalEntries: { $sum: 1 },
        residentHelperEntries: { 
          $sum: { $cond: [{ $eq: ['$employee.employeeType', 'RESIDENT_HELPER'] }, 1, 0] } 
        },
        technicianEntries: { 
          $sum: { $cond: [{ $eq: ['$employee.employeeType', 'TECHNICIAN'] }, 1, 0] } 
        },
        otherEntries: { 
          $sum: { $cond: [{ $eq: ['$employee.employeeType', 'OTHER'] }, 1, 0] } 
        },
        todayEntries: {
          $sum: {
            $cond: [
              {
                $and: [
                  { $gte: ['$entryTime', new Date(new Date().setHours(0, 0, 0, 0))] },
                  { $lt: ['$entryTime', new Date(new Date().setHours(23, 59, 59, 999))] }
                ]
              },
              1,
              0
            ]
          }
        }
      }
    }
  ]);
};

// Instance method to get entry summary
employeeEntrySchema.methods.getSummary = function() {
  return {
    id: this._id,
    entryId: this.entryId,
    entryTime: this.entryTime,
    entryTimeFormatted: this.entryTimeFormatted,
    entryMessage: this.entryMessage,
    purpose: this.purpose,
    notes: this.notes,
    recordedByName: this.recordedByName,
    createdAt: this.createdAt
  };
};

module.exports = mongoose.model('EmployeeEntry', employeeEntrySchema);
