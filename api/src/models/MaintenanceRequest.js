const mongoose = require('mongoose');
const crypto = require('crypto');

const maintenanceRequestSchema = new mongoose.Schema({
  // Request Identification
  requestId: {
    type: String,
    unique: true,
    required: false, // Will be generated by pre-save hook
    trim: true
  },

  // Building Association
  buildingId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: [true, 'Building ID is required']
  },

  // Requester Information (who created the request)
  requesterId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Requester ID is required']
  },

  // Maintenance Details
  description: {
    type: String,
    required: [true, 'Description is required'],
    trim: true,
    maxlength: [600, 'Description cannot exceed 600 characters']
  },

  // Base64 Image Storage (following existing Photo model pattern)
  imageBase64: {
    type: String,
    required: false,
    validate: {
      validator: function(v) {
        if (!v) return true; // Optional field
        return v.startsWith('data:image/') && v.includes('base64,');
      },
      message: 'Image must be a valid base64 encoded image'
    }
  },

  imageMimeType: {
    type: String,
    required: false,
    default: 'image/jpeg'
  },

  imageSize: {
    type: Number,
    required: false,
    min: [1024, 'Image size must be at least 1KB'],
    max: [10485760, 'Image size cannot exceed 10MB'] // 10MB limit
  },

  // Status Tracking
  status: {
    type: String,
    required: true,
    enum: ['PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'],
    default: 'PENDING'
  },

  // Location Information
  location: {
    type: String,
    trim: true,
    maxlength: [200, 'Location cannot exceed 200 characters']
  },

  flatNumber: {
    type: String,
    trim: true,
    maxlength: [50, 'Flat number cannot exceed 50 characters']
  },

  // Admin Notes
  adminNotes: {
    type: String,
    trim: true,
    maxlength: [1000, 'Admin notes cannot exceed 1000 characters']
  },

  // Completion Information
  completedAt: {
    type: Date
  },

  completedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },

  completionNotes: {
    type: String,
    trim: true,
    maxlength: [1000, 'Completion notes cannot exceed 1000 characters']
  },

  // Timestamps
  createdAt: {
    type: Date,
    default: Date.now
  },

  updatedAt: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

// Indexes for better performance
maintenanceRequestSchema.index({ buildingId: 1, createdAt: -1 });
maintenanceRequestSchema.index({ requesterId: 1, createdAt: -1 });
maintenanceRequestSchema.index({ requestId: 1 });
maintenanceRequestSchema.index({ status: 1 });

// Pre-save middleware to generate requestId
maintenanceRequestSchema.pre('save', async function(next) {
  try {
    if (!this.requestId) {
      this.requestId = await this.constructor.generateRequestId();
    }
    this.updatedAt = new Date();
    next();
  } catch (error) {
    next(error);
  }
});

// Static method to generate unique request ID
maintenanceRequestSchema.statics.generateRequestId = async function() {
  let isUnique = false;
  let newRequestId;
  
  while (!isUnique) {
    const timestamp = Date.now();
    const randomString = Math.random().toString(36).substring(2, 7).toUpperCase();
    newRequestId = `MAINT_${timestamp}_${randomString}`;
    
    const existingRequest = await this.findOne({ requestId: newRequestId });
    if (!existingRequest) {
      isUnique = true;
    }
  }
  
  return newRequestId;
};

// Virtual for formatted creation time
maintenanceRequestSchema.virtual('createdAtFormatted').get(function() {
  return this.createdAt ? new Date(this.createdAt).toLocaleString('en-IN', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: true
  }) : null;
});

// Virtual for formatted completion time
maintenanceRequestSchema.virtual('completedAtFormatted').get(function() {
  return this.completedAt ? new Date(this.completedAt).toLocaleString('en-IN', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: true
  }) : null;
});

// Virtual for image URL (if base64 data exists)
maintenanceRequestSchema.virtual('imageUrl').get(function() {
  if (this.imageBase64) {
    return this.imageBase64; // Return base64 data directly
  }
  return null;
});

// Static method to get requests by building
maintenanceRequestSchema.statics.getByBuilding = function(buildingId, filters = {}) {
  const query = { buildingId };
  
  // Status filter
  if (filters.status) {
    query.status = filters.status;
  }
  
  // Date range filter
  if (filters.startDate && filters.endDate) {
    query.createdAt = {
      $gte: new Date(filters.startDate),
      $lte: new Date(filters.endDate)
    };
  } else if (filters.today) {
    const startOfToday = new Date();
    startOfToday.setHours(0, 0, 0, 0);
    const endOfToday = new Date();
    endOfToday.setHours(23, 59, 59, 999);
    query.createdAt = {
      $gte: startOfToday,
      $lte: endOfToday
    };
  }
  
  return this.find(query)
    .populate('requesterId', 'name role email phoneNumber flatNumber')
    .populate('buildingId', 'name address')
    .populate('completedBy', 'name role')
    .sort({ createdAt: -1 });
};

// Static method to get request statistics
maintenanceRequestSchema.statics.getRequestStats = async function(buildingId, startDate, endDate) {
  const matchStage = { buildingId: new mongoose.Types.ObjectId(buildingId) };

  if (startDate && endDate) {
    matchStage.createdAt = {
      $gte: new Date(startDate),
      $lte: new Date(endDate)
    };
  }

  const todayStart = new Date();
  todayStart.setHours(0, 0, 0, 0);
  const todayEnd = new Date();
  todayEnd.setHours(23, 59, 59, 999);

  const todayMatchStage = {
    buildingId: new mongoose.Types.ObjectId(buildingId),
    createdAt: { $gte: todayStart, $lte: todayEnd }
  };

  const stats = await this.aggregate([
    { $match: matchStage },
    {
      $group: {
        _id: null,
        totalRequests: { $sum: 1 },
        pendingRequests: { $sum: { $cond: [{ $eq: ['$status', 'PENDING'] }, 1, 0] } },
        inProgressRequests: { $sum: { $cond: [{ $eq: ['$status', 'IN_PROGRESS'] }, 1, 0] } },
        completedRequests: { $sum: { $cond: [{ $eq: ['$status', 'COMPLETED'] }, 1, 0] } },
        cancelledRequests: { $sum: { $cond: [{ $eq: ['$status', 'CANCELLED'] }, 1, 0] } }
      }
    }
  ]);

  const todayStats = await this.aggregate([
    { $match: todayMatchStage },
    {
      $group: {
        _id: null,
        todayRequests: { $sum: 1 }
      }
    }
  ]);

  return {
    totalRequests: stats[0]?.totalRequests || 0,
    pendingRequests: stats[0]?.pendingRequests || 0,
    inProgressRequests: stats[0]?.inProgressRequests || 0,
    completedRequests: stats[0]?.completedRequests || 0,
    cancelledRequests: stats[0]?.cancelledRequests || 0,
    todayRequests: todayStats[0]?.todayRequests || 0
  };
};

module.exports = mongoose.model('MaintenanceRequest', maintenanceRequestSchema);
