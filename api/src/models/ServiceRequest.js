const mongoose = require('mongoose');
const crypto = require('crypto');

const serviceRequestSchema = new mongoose.Schema({
  // Request Identification
  requestId: {
    type: String,
    unique: true,
    required: false, // Will be generated by pre-save hook
    trim: true
  },

  // Building Association
  buildingId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: [true, 'Building ID is required']
  },

  // Employee Information (who will handle the request) - Optional, can be assigned later
  employeeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Employee',
    required: false // Made optional - can be assigned later
  },

  // Requester Information (who created the request)
  requesterId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Requester ID is required']
  },

  // Request Details
  requestType: {
    type: String,
    required: [true, 'Request type is required'],
    enum: ['PLUMBING', 'ELECTRICAL', 'HOUSE_HELP', 'MAINTENANCE', 'CLEANING', 'OTHER'],
    default: 'OTHER'
  },

  requestTypeDisplay: {
    type: String,
    required: true,
    default: 'Other'
  },

  title: {
    type: String,
    trim: true,
    maxlength: [200, 'Title cannot exceed 200 characters']
  },

  description: {
    type: String,
    required: [true, 'Description is required'],
    trim: true,
    maxlength: [2000, 'Description cannot exceed 2000 characters']
  },

  // Priority and Urgency
  priority: {
    type: String,
    required: true,
    enum: ['LOW', 'MEDIUM', 'HIGH', 'URGENT'],
    default: 'MEDIUM'
  },

  urgency: {
    type: String,
    required: true,
    enum: ['NORMAL', 'URGENT', 'EMERGENCY'],
    default: 'NORMAL'
  },

  // Status Tracking
  status: {
    type: String,
    required: true,
    enum: ['PENDING', 'ASSIGNED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED', 'REJECTED'],
    default: 'PENDING'
  },

  // Location Information
  location: {
    type: String,
    trim: true,
    maxlength: [500, 'Location cannot exceed 500 characters']
  },

  flatNumber: {
    type: String,
    trim: true,
    maxlength: [50, 'Flat number cannot exceed 50 characters']
  },

  // Scheduling
  preferredDate: {
    type: Date
  },

  preferredTime: {
    type: String,
    trim: true,
    maxlength: [100, 'Preferred time cannot exceed 100 characters']
  },

  // Completion Information
  completedAt: {
    type: Date
  },

  completedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },

  completionNotes: {
    type: String,
    trim: true,
    maxlength: [1000, 'Completion notes cannot exceed 1000 characters']
  },

  // Admin Notes
  adminNotes: {
    type: String,
    trim: true,
    maxlength: [1000, 'Admin notes cannot exceed 1000 characters']
  },

  // Cost Information
  estimatedCost: {
    type: Number,
    min: [0, 'Estimated cost cannot be negative']
  },

  actualCost: {
    type: Number,
    min: [0, 'Actual cost cannot be negative']
  },

  costApproved: {
    type: Boolean,
    default: false
  },

  // Timestamps
  createdAt: {
    type: Date,
    default: Date.now
  },

  updatedAt: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

// Indexes for better performance
serviceRequestSchema.index({ buildingId: 1, createdAt: -1 });
serviceRequestSchema.index({ employeeId: 1, status: 1 });
serviceRequestSchema.index({ requesterId: 1, createdAt: -1 });
serviceRequestSchema.index({ requestId: 1 });
serviceRequestSchema.index({ status: 1, priority: 1 });
serviceRequestSchema.index({ requestType: 1, status: 1 });

// Pre-save middleware to generate requestId
serviceRequestSchema.pre('save', async function(next) {
  try {
    if (!this.requestId) {
      this.requestId = await this.constructor.generateRequestId();
    }
    this.updatedAt = new Date();
    next();
  } catch (error) {
    next(error);
  }
});

// Static method to generate unique request ID
serviceRequestSchema.statics.generateRequestId = async function() {
  let isUnique = false;
  let newRequestId;
  
  while (!isUnique) {
    const timestamp = Date.now();
    const randomString = Math.random().toString(36).substring(2, 7).toUpperCase();
    newRequestId = `REQ_${timestamp}_${randomString}`;
    
    const existingRequest = await this.findOne({ requestId: newRequestId });
    if (!existingRequest) {
      isUnique = true;
    }
  }
  
  return newRequestId;
};

// Virtual for formatted creation time
serviceRequestSchema.virtual('createdAtFormatted').get(function() {
  return this.createdAt ? new Date(this.createdAt).toLocaleString('en-IN', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: true
  }) : null;
});

// Virtual for formatted completion time
serviceRequestSchema.virtual('completedAtFormatted').get(function() {
  return this.completedAt ? new Date(this.completedAt).toLocaleString('en-IN', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: true
  }) : null;
});

// Static method to get requests by building
serviceRequestSchema.statics.getByBuilding = function(buildingId, filters = {}) {
  const query = { buildingId };
  
  // Status filter
  if (filters.status) {
    query.status = filters.status;
  }
  
  // Request type filter
  if (filters.requestType) {
    query.requestType = filters.requestType;
  }
  
  // Priority filter
  if (filters.priority) {
    query.priority = filters.priority;
  }
  
  // Date range filter
  if (filters.startDate && filters.endDate) {
    query.createdAt = {
      $gte: new Date(filters.startDate),
      $lte: new Date(filters.endDate)
    };
  } else if (filters.today) {
    const startOfToday = new Date();
    startOfToday.setHours(0, 0, 0, 0);
    const endOfToday = new Date();
    endOfToday.setHours(23, 59, 59, 999);
    query.createdAt = {
      $gte: startOfToday,
      $lte: endOfToday
    };
  }
  
  return this.find(query)
    .populate('employeeId', 'name employeeType employeeTypeDisplay phoneNumber employeeCode')
    .populate('requesterId', 'name role email phoneNumber flatNumber')
    .populate('buildingId', 'name address')
    .populate('completedBy', 'name role')
    .sort({ createdAt: -1 });
};

// Static method to get request statistics
serviceRequestSchema.statics.getRequestStats = async function(buildingId, startDate, endDate) {
  const matchStage = { buildingId: new mongoose.Types.ObjectId(buildingId) };

  if (startDate && endDate) {
    matchStage.createdAt = {
      $gte: new Date(startDate),
      $lte: new Date(endDate)
    };
  }

  const todayStart = new Date();
  todayStart.setHours(0, 0, 0, 0);
  const todayEnd = new Date();
  todayEnd.setHours(23, 59, 59, 999);

  const todayMatchStage = {
    buildingId: new mongoose.Types.ObjectId(buildingId),
    createdAt: { $gte: todayStart, $lte: todayEnd }
  };

  const stats = await this.aggregate([
    { $match: matchStage },
    {
      $group: {
        _id: null,
        totalRequests: { $sum: 1 },
        pendingRequests: { $sum: { $cond: [{ $eq: ['$status', 'PENDING'] }, 1, 0] } },
        inProgressRequests: { $sum: { $cond: [{ $eq: ['$status', 'IN_PROGRESS'] }, 1, 0] } },
        completedRequests: { $sum: { $cond: [{ $eq: ['$status', 'COMPLETED'] }, 1, 0] } },
        urgentRequests: { $sum: { $cond: [{ $eq: ['$priority', 'URGENT'] }, 1, 0] } },
        plumbingRequests: { $sum: { $cond: [{ $eq: ['$requestType', 'PLUMBING'] }, 1, 0] } },
        electricalRequests: { $sum: { $cond: [{ $eq: ['$requestType', 'ELECTRICAL'] }, 1, 0] } },
        houseHelpRequests: { $sum: { $cond: [{ $eq: ['$requestType', 'HOUSE_HELP'] }, 1, 0] } }
      }
    }
  ]);

  const todayStats = await this.aggregate([
    { $match: todayMatchStage },
    {
      $group: {
        _id: null,
        todayRequests: { $sum: 1 }
      }
    }
  ]);

  return {
    totalRequests: stats[0]?.totalRequests || 0,
    pendingRequests: stats[0]?.pendingRequests || 0,
    inProgressRequests: stats[0]?.inProgressRequests || 0,
    completedRequests: stats[0]?.completedRequests || 0,
    urgentRequests: stats[0]?.urgentRequests || 0,
    plumbingRequests: stats[0]?.plumbingRequests || 0,
    electricalRequests: stats[0]?.electricalRequests || 0,
    houseHelpRequests: stats[0]?.houseHelpRequests || 0,
    todayRequests: todayStats[0]?.todayRequests || 0
  };
};

module.exports = mongoose.model('ServiceRequest', serviceRequestSchema);
